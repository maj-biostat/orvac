---
title: "Orvac Simulation Results"
author: "Mark Jones"
date: "`r Sys.time()`"
output:
  html_document:
    classoption: landscape
    css: style.css
    number_sections: yes
    self_contained: yes
    theme: united
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
  word_document:
    toc: yes
    toc_depth: '3'
geometry: left=0.2cm,right=0.2cm,top=1cm,bottom=1cm
editor_options:
  chunk_output_type: console
classoption: landscape
---

<!--    toc: yes
    toc_float: true -->

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path = 'figs/')
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(psych))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(htmltools))
suppressPackageStartupMessages(library(orvacsim))
source("util.R")


getsum <- function(x){
  mysummary <- data.frame(NA_real_, NA_character_, NA_real_, NA_real_,
                NA_real_, NA_real_,  NA_real_,  as.numeric(1),
                mean(x$i_c_mean), mean(x$i_c_sd),  mean(x$i_t_mean),
                mean(x$i_t_sd), mean(x$c_c_mean), mean(x$c_c_sd),
                mean(x$c_c_mean), mean(x$c_c_sd),
                geometric.mean(x$pct_fut), mean(x$ss_fut_mean),
                mean(x$ss_fut_sd), mean(x$ss_fut_med),
                geometric.mean(x$pct_sup), mean(x$ss_sup_mean),
                mean(x$ss_sup_sd),  mean(x$ss_sup_med),
                geometric.mean(x$pct_stopv),  mean(x$ss_stopv_mean),
                mean(x$ss_stopv_sd), mean(x$ss_stopv_med), NA_character_,
                stringsAsFactors = F)
    row.names(mysummary) <- NULL
    names(mysummary) <- names(x)
    mysummary
}


ggplot2::theme_set(ggplot2::theme_bw())
ggplot2::theme_update(text = element_text(size = 10))
ggplot2::theme_update(legend.position = "top")
# ggplot2::theme_update(legend.title = element_blank())
ggplot2::theme_update(axis.text.x = element_text(size = 10))
ggplot2::theme_update(axis.text.y = element_text(size = 10))

# Work|Right|Fast
# rmarkdown::render("simulation_report.Rmd", clean=TRUE)
```


# Preamble
***
Simulation results for ORVAC shown in graphical and table form.

## Frequenist power/SS



```{r, echo = F}
dpwr1 <- data.frame(t0 = c(30,30,30,30),
                    t1 = c(35,40,45,50),
                    diff = c(5,10,15,20),
                    ss = c(400,350,310,270),
                    pwr = c(0.25,0.39,0.62,0.63))
dpwr1 <- dpwr1[order(dpwr1$diff), ]
digits <- c(0, 0, 0, 0, 2)
options(knitr.kable.NA = '-')
```

```{r, echo = F, eval = F}
# just some conde to get the survival probs at the end of the study
# these are used to calc power in stata.
cfg <- readRDS("cfg-test.RDS")
m0 <- 30
m1 <- 50
# ss <- c(400, 350, 300, 280)
ss <- 270
cfg$looks

cfg$b0tte <- log(2)/m0
cfg$b1tte <- (log(2)/m1 - (log(2)/m0))

look <- which(cfg$looks == ss)
cfg$max_age_fu_months <- 36

d <- rcpp_dat(cfg)
for(i in 1:nrow(d)){
  # i = i + 1
  (visits <- rcpp_visits(d, i-1, look, cfg))
  (cens <- rcpp_cens_interim(d, visits, i-1, look, cfg))
  d[i, COL_CEN] <- cens$cen
  d[i, COL_OBST] <- cens$obst
}

colnames(d) <- dnames
d <- as.data.frame(d)
d <- d[1:ss,]

library(survival)
fit <- survfit(Surv(obst, cen == 0) ~ trt, data=d)
plot(fit)
dsurv <- data.frame(psurv = fit$surv, trt = rep(0:1, each = ss/2), time = fit$time)
dsurv %>% dplyr::group_by(trt) %>%
  slice(which.max(time)) %>%
  select(everything()) 

```

Table 1 shows the statistical power from a log-rank test at sample sizes drawn from the simulation results (approx. expected SS from Bayesian trial having accrual of 40 per quarter).

```{r, echo = F, eval = T}
kable(dpwr1,
      caption = "Table 1. Frequentist power for time-to-event analysis",
      col.names = c("ctl", "trt", "diff", "", ""),
      digits = digits) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F, position = "left",
                font_size = 12,
                latex_options = "hold_position") %>%
  add_header_above(c("Median Time to Evnt" = 3, "SS" = 1, "Power" = 1)) %>%
  column_spec(1:5, width = "1.5cm", bold = F, italic = F)

```

Table 2 shows the statistical power from a (one sided 0.05) chisq test on the comparison of proportions (n=250). Note how the baseline rate influences power.

```{r, echo = F}
dpwr1 <- data.frame(p0 = c(0.2,    0.2,  0.3,  0.3,  0.4,  0.4),
                    p1 = c(0.3,    0.4,  0.4,  0.5,  0.5,  0.6),
                    diff = c(0.1,  0.2,  0.1,  0.2,  0.1,  0.2),
                    ss = c(150,    150,  150,  150,  150,  150),
                    pwr = c(0.41,  0.85, 0.36, 0.81, 0.34,  0.79))
dpwr1 <- dpwr1[order(dpwr1$diff), ]
digits <- c(2, 2, 2, 0, 2)
options(knitr.kable.NA = '-')
rownames(dpwr1) <- NULL
```

```{r, echo = F, eval = T}
kable(dpwr1,
      caption = "Table 2. Frequentist power for comparison of proportions",
      col.names = c("ctl", "trt", "diff", "", ""),
      digits = digits) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F, position = "left",
                font_size = 12,
                latex_options = "hold_position") %>%
  add_header_above(c("Proportion Seroconverted" = 3, "SS" = 1, "Power" = 1)) %>%
  column_spec(1:5, width = "1.5cm", bold = F, italic = F)

```


# Results from simulation scenarios
***
The following tables and plots summarise the scenarios that were simulated. 

Analysis is all based on conjugate priors (vaguely informative for the time to event, uniform on seroconversion). 

For the clinical endpoint we assess whether the probability of the ratio of median survival times is greater than 1 (equivalent to hazard ratio for the distribution used). Thresholds for deciding superiority were 0.96 at each interim and 0.95 at the final analysis. For the futility check, each trial that was simulated conditional on the current posterior was assessed against a threshold of 0.95. If less than 5% of the trials were successful (i.e. if in less than 5% of the trials we saw a treatment effect) then futility was declared.

For the immunological endpoint we assess whether the difference in seroconversion rates is greater than 0 (treatment versus control, i.e. one-sided). Stopping venous sampling was based on a threshold of 0.96 and 0.95 at the final analysis. For the futility check, each trial simulated conditional on the current posterior was assessed against a threshold of 0.95 and if less than 5% of the trials were successful then futility was declared.





```{r, echo = F}
mywarnings <- list()

post_final_thresh <- 0

resfiles <- list.files("out_simple_censoring", pattern = "*.RDS")

df_all <- data.frame(stringsAsFactors = F)
df_fig1 <- data.frame(stringsAsFactors = F)

for(fname in resfiles){
  d1 <- readRDS(file.path(getwd(), "out_simple_censoring", fname))
  # d1 <- readRDS(file.path(getwd(), "out", resfiles[1]))

  mywarnings[[d1$cfg$idsim]] <- d1$warnings
  
  
  df_res <- as.data.frame(d1$results)
  
  if(apply(df_res, 2, class)[1] == "list"){
     dnam <- names(df_res)
    df_res <- as.data.frame(do.call(cbind, 
                                    lapply(1:ncol(df_res), 
                                           function(x) unlist(df_res[,x]))))
    colnames(df_res) <- dnam
  }

  nsim <- d1$cfg$nsims
  # true values for median surv (mnth)
  baseclin <- med_surv(d1$cfg$b0tte)
  trtclin <- med_surv(d1$cfg$b0tte + d1$cfg$b1tte)
  # true values for seroconversion prob
  basesero <- d1$cfg$baselineprobsero
  trtsero <- d1$cfg$trtprobsero
  # accrual
  accrual <- d1$cfg$people_per_interim_period
  info_delay <- d1$cfg$sero_info_delay
  alt_cen <- d1$cfg$use_alt_censoring
  
  # thresholds
  post_final_thresh <- d1$cfg$post_final_thresh
  
  # what did we conclude from interims
  outcome_labs <- c("Futile", "Superior", "Inconclusive")
  df_res$interim_outcome <- NA
  df_res$interim_outcome <- ifelse(df_res$stop_i_fut == 1 | 
                                     df_res$stop_c_fut == 1, 1, df_res$interim_outcome)
  df_res$interim_outcome <- ifelse(df_res$stop_c_sup == 1, 2, df_res$interim_outcome)
  df_res$interim_outcome <- ifelse(df_res$inconclu == 1, 3, df_res$interim_outcome)
  df_res$interim_outcome <- factor(df_res$interim_outcome, 
                                   levels = 1:3, 
                                   labels = outcome_labs)
  
  # trials are either futile or superior 
  df_outcome <- df_res %>%
    dplyr::filter(interim_outcome %in% c("Futile", "Superior", "Inconclusive") )
    
  df_stopv <- df_res %>%
    dplyr::filter(stop_v_samp == 1) 
  
  n <- c(table(df_res$interim_outcome),   nrow(df_stopv))
  names(n) <- c("Futile","Superior","Inconclusive", "StopV"    )
  prob <- c(prop.table(table(df_res$interim_outcome)),   
            nrow(df_stopv)/max(df_res$idxsim))
  names(prob) <- c(names(prob)[1:3], "StopV")

  df_ss_clin <- df_outcome %>% 
    dplyr::summarise(ss_mean = mean(ss_clin), 
                     ss_sd = sd(ss_clin)) 
  
  df_ss_immu <- df_outcome %>% 
    dplyr::summarise(ss_mean = mean(ss_immu), 
                     ss_sd = sd(ss_immu)) 
  

  df_outcome$look_cut <- cut(df_outcome$look, breaks = c(0, 250, 500, 750, 1000), 
                             include.lowest = T, right = F)
  
  prob_ss <- prop.table(table(df_outcome$look_cut))
  prob_ss <- as.numeric(cumsum(prob_ss))
  
  # what did the final analysis say?
  probimmi <- sum(df_res$i_final) / max(df_res$idxsim)
  probclin <- sum(df_res$c_final) / max(df_res$idxsim)
  
  flab <- gsub("res-", "", fname)
  flab <- gsub('.RDS', "", flab)
  
  mydate <- as.POSIXlt(flab, format="%Y-%m-%d-%H-%M-%S")
  
  # does the interim match the final conclusion? 
  immu_intrm_vs_fin <- mean(df_outcome$stop_i_fut == 1-df_outcome$i_final)
  clin_intrm_vs_fin <- mean(df_outcome$stop_c_sup == df_outcome$c_final)

  dtmp <- data.frame(idsim = d1$cfg$idsim,
                     nsim = nsim,

                     basesero = basesero,
                     trtsero = trtsero,
                     baseclin = baseclin,
                     trtclin = trtclin,
                     accrual = accrual,
                     info_delay = info_delay,
                     
                     prob_sup = prob["Superior"],
                     prob_fut = prob["Futile"],
                     prob_incon = prob["Inconclusive"],
                     prob_stopv = prob["StopV"],
                     
                     n_sup = n["Superior"],
                     n_fut = n["Futile"],
                     n_incon = n["Inconclusive"],
                     n_stopv = n["StopV"],
    
                     # overall mean ss for clin and immu
    
                     ss_clin_mean = as.numeric(df_ss_clin["ss_mean"]),
                     ss_clin_sd = as.numeric(df_ss_clin["ss_sd"]),
    
                     ss_immu_mean = as.numeric(df_ss_immu["ss_mean"]),
                     ss_immu_sd = as.numeric(df_ss_immu["ss_sd"]),

                     prob_ss_lt250 = as.numeric(prob_ss[1]),
                     prob_ss_lt500 = as.numeric(prob_ss[2]),
                     prob_ss_lt750 = as.numeric(prob_ss[3]),
                     prob_ss_lt1k = as.numeric(prob_ss[4]),

                     # probability of success at the final analysis 
                     # (proportion of trials where final analysis 
                     # showed a difference b/w groups)
                     
                     # the rest did not show a difference
                     prob_fin_immi = probimmi,
                     prob_fin_clin = probclin,
    
                     p_i_intrm_vs_fin = immu_intrm_vs_fin,
                     p_c_intrm_vs_fin = clin_intrm_vs_fin,
    
                     fname = flab, stringsAsFactors = F, 
                     alt_cen = alt_cen, 
                     date = mydate)
  
  # summary data
  dtmp <- dtmp %>%
    dplyr::mutate(f_prob_sup = sprintf("%.3f", prob_sup, n_sup),
                  f_prob_fut = sprintf("%.3f", prob_fut, n_fut),
                  f_prob_stopv = sprintf("%.3f", prob_stopv, n_stopv),
                  f_prob_incon = sprintf("%.3f", prob_incon, n_incon),
                  
                  f_ss_clin = sprintf("%.0f (%.1f)", ss_clin_mean, ss_clin_sd),
                  f_ss_immu = sprintf("%.0f (%.1f)", ss_immu_mean, ss_immu_sd),
      
                  f_ss_lt1 = sprintf("%.2f", prob_ss_lt250),
                  f_ss_lt2 = sprintf("%.2f", prob_ss_lt500),
                  f_ss_lt3 = sprintf("%.2f", prob_ss_lt750),
                  f_ss_lt4 = sprintf("%.2f", prob_ss_lt1k),

                  f_prob_fin_immi = sprintf("%.3f", prob_fin_immi),
                  f_prob_fin_clin = sprintf("%.3f", prob_fin_clin), 
                  
                  f_i_intrm_vs_fin = sprintf("%.2f", p_i_intrm_vs_fin),
                  f_c_intrm_vs_fin = sprintf("%.2f", p_c_intrm_vs_fin))

  df_all <- rbind(df_all,  dtmp, stringsAsFactors  = F)
  
  # figures
  df_outcome$fname <- fname
  df_outcome$simname <- d1$cfg$idsim
  df_fig1 <- rbind(df_fig1,  df_outcome, stringsAsFactors  = F)

}


df_0 <- df_all %>%
  dplyr::arrange(desc(fname)) %>%
  dplyr::mutate(row = 1:n()) %>%
  dplyr::select(row, nsim, 
                baseclin, trtclin, basesero, trtsero, accrual,info_delay,
                f_prob_sup, f_prob_fut, f_prob_stopv, f_prob_incon, 
                f_ss_clin, f_ss_immu, 
                f_ss_lt1, f_ss_lt2, f_ss_lt3,
                f_prob_fin_clin, f_prob_fin_immi, 
                f_c_intrm_vs_fin, f_i_intrm_vs_fin, 
                fname, idsim, alt_cen, date) %>%
  dplyr::select(-row) 

df_blank <- df_0 %>% dplyr::slice(1L) 


digits <- c(0, 0, 2, 2, 0, 2,
            0, 0, 0, 0, 0,0,0,
            0, 0, 0, 0, 0, 0, 0)
options(knitr.kable.NA = '-')
showwarn <- length(mywarnings > 0)

```



## Threshold Probabilities

Table 3 shows the threshold values used to assess adaptive elements in the simulations results that follow.


```{r, echo = F, eval = T}



d_thres <- data.frame(threshname = c("post_final_thresh",
                                     "pp_sero_sup_thresh",
                                     "post_tte_sup_thresh",
                                     "post_sero_win_thresh",
                                     "post_tte_win_thresh",
                                     "pp_sero_fut_thresh",
                                     "pp_tte_fut_thresh"), 
                      thresh = c(0.96, 0.96, 0.96, 0.96, 0.96, 0.05, 0.05),
                      desc = c("To assess each EPs at the final analysis.",
                               "To assess whether venous sampling should be ceased due to superiority.",
                               "To assess whether clinical EP should be ceased due to expected success.",
                               "To assess superiority in immunological EP for trials generated from posterior predictive distribution.",
                               "To assess superiority in clinical EP for trials generated from posterior predictive distribution.",
                               "To assess proportion of trials where immunological EP is successful during futility check.",
                               "To assess proportion of trials where clinical EP is successful during futility check."))

kable(d_thres,
      caption = "Table 3. Decision thresholds",
      col.names = c("Threshold", "Value", "Description"),
      digits = c(0, 2, 0)) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F, 
                position = "left",
                font_size = 12,
                latex_options = "hold_position") %>%
  column_spec(3, width = "10cm", bold = F, italic = F)

```

## Reading the tables

From left to right tables show:

+ true baseline median survival time 
+ delta_tte = (treatment median survival time) - (baseline median survival time)
+ true baseline seroconversion probability
+ delta_sero = (treatment seroconversion probability) - (baseline seroconversion probability)

+ accrual -- number of people per 3 month period (i.e. time between interims)
+ information delay (in months) to obtain seroconversion results

+ probability of expected success 
+ probability of expected futility 
+ probability of stopping venous sampling 
+ probability of no decision

+ mean (sd) of participants enrolled
+ mean (sd) of participants with blood sample results
+ probability that trial stops before 250, 500 and 750 enrolled participants
+ number of events in each arm (ctl/trt) at time trial stopped

+ proportion of trials where the final analysis indicated a treatment difference in clinical endpoint
+ proportion of trials where the final analysis indicated a treatment difference in immunological endpoint


## Type I Error

```{r, echo = showwarn, eval=showwarn}
print("WARNINGS PRESENT IN DATA!!")
```

Null scenarios showing control of type-i error < 0.05 on the clinical endpoint. Repeat runs are shown, each started with a different seed. The type-i for stopping venous sampling is nominally above 0.05 for some scenarios. 

```{r, echo = F, eval = T}

kable(df_0 %>% 
        #dplyr::filter(accrual == 50) %>%
        dplyr::mutate(delta = trtclin - baseclin, 
                      gamma = trtsero - basesero) %>%
        dplyr::filter(delta == 0 & gamma == 0) %>%
        dplyr::select(-idsim, -nsim, -alt_cen, -date, 
                      -delta, -gamma) %>%
    dplyr::arrange(desc(fname)),
      caption = "Table 4. Simulation Null Scenarios",
      col.names = c("ctl", "trt", "ctl", "trt", "accrual", "delay",
                    "e.s.", "e.f", "s.v.", "n.d", 
                    "enrolled", "blood res", "P(<250)", "P(<500)", 
                    "P(<750)", 
                    "clin", "immu", "clin", "immu", "fname"),
      digits = digits) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F, position = "left",
                font_size = 12,
                latex_options = "hold_position") %>%
  add_header_above(c("Clinical" = 2, "Seroconversion" = 2, 
                     "Info rate" = 2, 
                     "Interim" = 4,
                     "SS" = 5, 
                     "Wins @ final" = 2, "!Flip-flop" = 2, " " = 1))

```


## Expected Success

Power increases as a function of effect size, is higher at the extremes of baseline seroconversion probability and increases with accrual rates.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}

df_tmp <- df_all %>%
        #dplyr::filter(accrual !=30) %>%
  dplyr::mutate(delta = trtclin - baseclin,
                gamma = trtsero - basesero) %>%
  dplyr::filter(delta > 0 & gamma > 0) %>%
  dplyr::group_by(basesero, trtsero, trtclin, 
                  baseclin, accrual, info_delay, delta, gamma) %>%
  dplyr::summarise(prob_sup = mean(prob_sup)) %>%
  dplyr::ungroup()
  

ggplot(df_tmp, aes(x = delta, y = prob_sup, 
                   group = paste(accrual, ":", baseclin), 
                   linetype = paste0(accrual), 
                   colour = paste0(baseclin))) +
  geom_point(size = 0.9) + 
  geom_line(size = 0.9) + 
  scale_color_manual(name = "Baseline clinical (mnths): ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference median survival time (mnths)", 
                     breaks = seq(from = 5, to = 15, by = 5)) +
  scale_y_continuous("P(e.s.)", 
                     breaks = seq(from = 0, to = 1, by = 0.1), 
                     lim = c(0, 1)) +
  facet_grid(paste0("Baseline sero = ", basesero ) ~ paste0("Diff in sero rate = ", gamma)) 
```

## (Expected) Futility

Futility decreases with effect size. Increasing accrual rates tend to decrease the probability of futility with the effects being more start when the baseline seroconversion rate is low.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}

df_tmp <- df_all %>%
       # dplyr::filter(accrual !=30) %>%
  dplyr::mutate(delta = trtclin - baseclin,
                gamma = trtsero - basesero) %>%
  dplyr::filter(delta > 0 & gamma > 0) %>%
  dplyr::group_by(basesero, trtsero, trtclin, baseclin, 
                  accrual, info_delay, delta, gamma) %>%
  dplyr::summarise(prob_fut = mean(prob_fut)) %>%
  dplyr::ungroup()

ggplot(df_tmp, aes(x = delta, y = prob_fut, 
                   group = paste(accrual, ":", baseclin), 
                   linetype = paste0(accrual), 
                   colour = paste0(baseclin))) +
  geom_line() + 
  scale_color_manual(name = "Baseline clinical (mnths): ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference median survival time (mnths)", 
                     breaks = seq(from = 5, to = 15, by = 5)) +
  scale_y_continuous("P(e.f.)", 
                     breaks = seq(from = 0, to = 1, by = 0.1), 
                     lim = c(0, 1)) +
  facet_grid(paste0("Baseline sero = ", basesero ) ~ paste0("Diff in sero rate = ", gamma)) 

```


## Stop Venous Sampling

Is based on finding strong evidence of an effect in the immunological endpoint. The chacarteristics follow those in a standard logistic regression - extreme baseline probabilities tend to increase power.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}
df_tmp <- df_all %>%
      #  dplyr::filter(accrual !=30) %>%
  dplyr::mutate(gamma = trtsero - basesero) %>%
  dplyr::filter(gamma > 0) %>%
  dplyr::group_by(basesero, trtsero, accrual, info_delay, gamma) %>%
  dplyr::summarise(prob_stopv = mean(prob_stopv)) %>%
  dplyr::ungroup()

ggplot(df_tmp, aes(x = gamma, y = prob_stopv, 
                   group = paste(accrual, ":", basesero), 
                   linetype = paste0(accrual), 
                   colour = paste0(basesero))) +
  geom_line() + 
  scale_color_manual(name = "Baseline sero: ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference in seroconversion rate", 
                     breaks = seq(from = 0.05, to = 0.15, by = 0.05)) +
  scale_y_continuous("P(s.v.)", 
                     breaks = seq(from = 0, to = 1, by = 0.1), 
                     lim = c(0, 1)) +
  facet_grid(paste0("Info delay = ", info_delay)  ~ 
               paste0("Baseline sero rate = ", basesero)) 

```


## No Decision (Inconclusive)

Rarely occurs and rapidly falls to zero as effect size gets larger.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}

df_tmp <- df_all %>%
      #  dplyr::filter(accrual !=30) %>%
  dplyr::mutate(delta = trtclin - baseclin,
                gamma = trtsero - basesero) %>%
  dplyr::filter(delta > 0 & gamma > 0) %>%
  dplyr::group_by(basesero, trtsero, trtclin, baseclin, accrual, info_delay, delta, gamma) %>%
  dplyr::summarise(prob_incon = mean(prob_incon)) %>%
  dplyr::ungroup()

ggplot(df_tmp, aes(x = delta, y = prob_incon, 
                   group = paste(accrual, ":", baseclin), 
                   linetype = paste0(accrual), 
                   colour = paste0(baseclin))) +
  geom_line() + 
  scale_color_manual(name = "Baseline clinical (mnths): ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference median survival time (mnths)", 
                     breaks = seq(from = 5, to = 15, by = 5)) +
  scale_y_continuous("P(n.d.)", 
                     breaks = seq(from = 0, to = 0.1, by = 0.02), lim = c(0, 0.1) ) +
  facet_grid(paste0("Baseline sero = ", basesero ) ~ paste0("Diff in sero rate = ", gamma)) 
 
```


## Sample Size 

### Total Enrolled 

Both sample size expectation and variability tend to decrease with increasing effect size. Higher accrual rates tend to be associated with higher expected sample size.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}

df_tmp <- df_all %>%
     #   dplyr::filter(accrual !=30) %>%
  dplyr::mutate(delta = trtclin - baseclin,
                gamma = trtsero - basesero) %>%
  dplyr::filter(delta > 0 & gamma > 0) %>%
  # dplyr::select(basesero, trtsero, trtclin, baseclin,
  #               accrual, info_delay, delta, gamma, ss_clin_mean, ss_clin_sd) %>%
  dplyr::group_by(basesero, trtsero, trtclin, baseclin, 
                  accrual, info_delay, delta, gamma) %>%
  dplyr::summarise(ss_clin_mean = mean(ss_clin_mean), 
                   n = n(), 
                   sum_var = sum(ss_clin_sd^2),
                   mean_var = sum_var / n,
                   mean_sd = sqrt(mean_var)) %>%
  dplyr::ungroup()


ggplot(df_tmp, aes(x = delta, y = ss_clin_mean, 
                   group = paste(accrual, ":", baseclin), 
                   linetype = paste0(accrual), 
                   colour = paste0(baseclin))) +
  geom_line() + 
  geom_point(size = 1) + 
  # geom_errorbar(aes(ymin = ss_clin_mean - mean_sd, 
  #   ymax = ss_clin_mean + mean_sd), size = 0.2, width = 0.5) + 
  scale_color_manual(name = "Baseline clinical (mnths): ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference median survival time (mnths)", 
                     breaks = seq(from = 5, to = 15, by = 5)) +
  scale_y_continuous("SS (mean +/- sd)", 
                     breaks = seq(from = 0, to = 1000, by = 100), 
                     lim = c(0, 1000)) +
  facet_grid(paste0("Baseline sero = ", basesero ) ~ paste0("Diff in sero rate = ", gamma))  

```


### Cohort with Bloods Taken

Sample size dependent on effect size and baseline rates in line with standard logistic regression characteristcs.

```{r, echo = F, eval = T, fig.height=4, fig.width=6}

df_tmp <- df_all %>%
     #   dplyr::filter(accrual !=30) %>%
  dplyr::mutate(gamma = trtsero - basesero) %>%
  dplyr::filter(gamma > 0 ) %>%
  dplyr::group_by(basesero, trtsero, 
                  accrual, info_delay, gamma) %>%
  dplyr::summarise(ss_immu_mean = mean(ss_immu_mean), 
                   n = n(), 
                   sum_var = sum(ss_immu_sd^2),
                   mean_var = sum_var / n,
                   mean_sd = sqrt(mean_var)) %>%
  dplyr::ungroup()


ggplot(df_tmp, aes(x = gamma, y = ss_immu_mean, 
                   group = accrual,
                   linetype = paste0(accrual)))  +
  geom_line() +
  geom_point() + 
  # geom_errorbar(aes(ymin = ss_immu_mean - mean_sd,
  #                   ymax = ss_immu_mean + mean_sd),
  #               size = 0.2, width = 0.005) +
  scale_color_manual(name = "Accrual (n per qtr)", values = cbp[2:5]) + 
  scale_linetype_discrete(name = "Accrual (n per qtr)") +
  scale_x_continuous("Difference b/w seroconversion rates",
                     breaks = seq(0.05, 0.15, by = 0.05)) +
  scale_y_continuous("SS (mean)", 
                     breaks = seq(from = 0, to = 250, by = 100), 
                     lim = c(0, 250))  +
  facet_grid( ~ paste0("Baseline sero rate = ", basesero)) 
```

## Consistency of Interim Decision with Final Analysis (flip-flop)

Shows the proportion of times that the final analysis is consistent with the interim decision that was made.

### Clinical

Results tend to increase in consistency as effect size increases. Higher accrual rates are associated with higher consistency rates.

```{r, echo = F, eval = T, fig.height=8, fig.width=6}

df_tmp <- df_all %>%
     #   dplyr::filter(accrual !=30) %>%
  dplyr::mutate(delta = trtclin - baseclin,
                gamma = trtsero - basesero) %>%
  dplyr::filter(delta > 0 & gamma > 0) %>%
  # dplyr::select(basesero, trtsero, trtclin, baseclin,
  #               accrual, info_delay, delta, gamma, ss_clin_mean, ss_clin_sd) %>%
  dplyr::group_by(basesero, trtsero, trtclin, baseclin, 
                  accrual, info_delay, delta, gamma) %>%
  dplyr::summarise(p_c_intrm_vs_fin = mean(p_c_intrm_vs_fin)) %>%
  dplyr::ungroup()


ggplot(df_tmp, aes(x = delta, y = p_c_intrm_vs_fin, 
                   group = paste(accrual, ":", baseclin), 
                   linetype = paste0(accrual), 
                   colour = paste0(baseclin))) +
  geom_line() + 
  scale_color_manual(name = "Baseline clinical (mnths): ", values = cbp[2:5]) +
  scale_linetype_discrete(name = "Accrual (per qtr)") +
  scale_x_continuous("Difference median survival time (mnths)", 
                     breaks = seq(from = 5, to = 15, by = 5)) +
  scale_y_continuous("Probability final analysis aligns with interim decision", 
    breaks = seq(from = 0, to = 1, by = 0.1), lim = c(0, 1)) +
  facet_grid(paste0("Baseline sero rate = ", basesero) ~ 
               paste0("Diff in sero rate = ", gamma)) 
```

### Immunological

Consistency increases with effect size.

```{r, echo = F, eval = T, fig.height=4, fig.width=6}
df_tmp <- df_all %>%
     #   dplyr::filter(accrual !=30) %>%
  dplyr::mutate(gamma = trtsero - basesero) %>%
  dplyr::filter(gamma > 0) %>%
  # dplyr::select(basesero, trtsero, trtclin, baseclin,
  #               accrual, info_delay, delta, gamma, ss_clin_mean, ss_clin_sd) %>%
  dplyr::group_by(basesero, trtsero, 
                  accrual, info_delay, gamma) %>%
  dplyr::summarise(p_i_intrm_vs_fin = mean(p_i_intrm_vs_fin)) %>%
  dplyr::ungroup()


ggplot(df_tmp, aes(x = gamma, y = p_i_intrm_vs_fin, 
                   group = paste0(accrual, ":", basesero), 
                   linetype = paste0(accrual),
                   colour = paste0(basesero)))  +
  geom_line() + 
  scale_color_manual(name = "Baseline seroconversion", values = cbp[2:5]) + 
  scale_linetype_discrete(name = "Accrual (n per qtr)") +
  scale_x_continuous("Difference seroconversion rate",
                     breaks = seq(0.05, 0.15, by = 0.05)) +
  scale_y_continuous("Probability final analysis aligns with interim decision", 
    breaks = seq(from = 0, to = 1, by = 0.1), lim = c(0, 1)) +
  theme(legend.position="right")+
  guides(col = guide_legend(nrow = 2))
  
```



## Combined Results

```{r, echo = showwarn, eval=showwarn}
print("WARNINGS PRESENT IN DATA!!")
```

Table 6 shows the combined the simulations results on which this report depends.




```{r, echo = F, eval = T}
kable(df_0 %>%
   #     dplyr::filter(accrual !=30) %>%
  dplyr::select(-idsim, -nsim, -alt_cen, -date) %>%
    dplyr::arrange(desc(fname))  ,
      caption = paste0("Table 6. Combined Simulation Results"),
      col.names = c("ctl", "trt", "ctl", "trt", "accrual", "delay",
                    "e.s.", "e.f", "s.v.", "n.d", 
                    "enrolled", "blood res", "P(<250)", "P(<500)", "P(<750)", 
                    "clin", "immu", "clin", "immu", "fname"),
      digits = digits) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F, position = "left",
                font_size = 12,
                latex_options = "hold_position") %>%
  add_header_above(c("Clinical" = 2, "Seroconversion" = 2, 
                     "Info rate" = 2, 
                     "Interim" = 4,
                     "SS" = 5, 
                     "Wins @ final" = 2, "!Flip-flop" = 2, " " = 1))

```



<!--

# Conclusions
***
1. In the null scenarios the type i error appears to be well controlled. If anything, there is scope to make the decision thresholds less conservative.
1. When there is only a seroconversion effect, the trial is likely to be indicated as futile. This is also true when the clinical endpoint is the only one in which we see an effect. This is because the futility decision is made when either the immunological or clinical endpoint show no effect.
1. While power increases as the twin effects increase, we only see 80%+ power when both the seroconversion and clinical effects are large (45% increase and 9 month increase respectively). Even in this scenario, the probability of a futile decision is still moderately high (0.17). 


```{r, echo = F, eval = F, fig.height=8, fig.width=12}
df_tmp <- df_clinsero1
df_tmp$accrual <- as.factor(df_tmp$accrual)
p1 <- ggplot(df_tmp, aes(x = baseclin, y = 100*pct_fut,
                         colour = accrual))+
              geom_point() +
  geom_line() +
  scale_colour_discrete(name = "Accrual per interim") +
  scale_x_continuous("Control arm median time to event") +
  scale_y_continuous("% futility", limits = c(0, 75)) +
  facet_grid(paste0("seroconversion control ", basesero) ~ paste0("sero trt ", trtsero))+
  theme(legend.position="top")

p2 <- ggplot(df_tmp, aes(x = baseclin, y = 100*pct_sup, colour = accrual))+
              geom_point() +
  geom_line() +
  scale_colour_discrete(name = "Accrual per interim") +
  scale_x_continuous("Control arm median time to event") +
  scale_y_continuous("% superiority", limits = c(25, 100)) +
  facet_grid(paste0("seroconversion control ", basesero) ~ paste0("sero trt ", trtsero))+
  theme(legend.position="top")

p3 <- ggplot(df_tmp, aes(x = baseclin, y = 100*pct_stopv, colour = accrual))+
              geom_point() +
  geom_line() +
  scale_colour_discrete(name = "Accrual per interim") +
  scale_x_continuous("Control arm median time to event") +
  scale_y_continuous("% cease venous", limits = c(50, 100)) +
  facet_grid(paste0("seroconversion control ", basesero) ~ paste0("sero trt ", trtsero))+
  theme(legend.position="top")

# gridExtra::grid.arrange(p1, p2, p3, ncol = 3,
#              top = grid::textGrob("Figure 1. Power as a function of simulation params",
#                             x = 0, y = 0.5,
#                             just = "left",
#                             gp = grid::gpar(fontsize = 12)))
```

# Data generation processes
***
We simulate 1000 trials by generating data as follows:

+ equal numbers of participants in the control and treatment arms accrued sequentially (treatment, control, treatment, control...etc)
+ age of participants based on a truncated normal distribution with the lower and upper bounds set to 6 and 12 months, a mean of 6.5 months and a standard deviation of 1 month (the age is used to assess censoring in the time to event analyses - we follow participants until 36 months)
+ accrual time (time of randomisation) is set sequentially for each participant. Specifically, the accrual times for participants $1, 2, 3, \dots, n$ are set to $0, t, 2t, 3t, \dots, (n-1)t$ where $t$ is the time required to accrue a single participant
+ for each participant, baseline seroconversion status is generated as a bernoulli random draw parameterised with $p$ equal to the baseline seroconversion probability
+ seroconversion status after the third dose/placebo is generated in the same fashion conditional on treatment status, baseline seroconversion status and treatment arm probability of seroconversion
+ time to event times are generated as draws from an exponential distribtion with rate parameter set conditional on treatment group status. Censoring occurs due to age at interim and events that are unobserved at the current interim time.
+ interim analyses are done on the basis of predictive probability
+ final analyses are complete after follow up. For the time to event analysis this means waiting until the youngest participant at the end of the enrollment period is 36 months old. For the immunological analysis this means we wait until all seroconversion results are obtained.

# Accrual rates
***
The word on the ground is that 50 per three month period is not realistic. The accrual rate is likely to be blocky due to seasonal effects and the effects of visits to remote communities where several kids might be accrued on the same day. Additionally, there is the possibility of additional sites coming on line. While Katherine is probably no longer an option, Alice may come on line around July 2019. Conservatively Alice may add 40 participants per year. At the moment the 2019 intake target is about 120 (in 2018 around 60 were enrolled). Urban recruitment remains very slow.

# Seroconversion modelling
***
The seroconversion model uses a beta conjugate prior to the bernoulli likelihood. The prior is uniform, i.e. $Beta(1, 1)$, i.e. uninformative. We model an information delay such that, at any given interim, some individuals will have been randomised and treated but seroconversion will still be pending. 

On the basis the seroconversions in each arm and the number of observed individuals at the interim, we compute the posterior distribution for the parameter of interest (probability of a successful trial, $p$). We do this for the control and treatment arms independently, yielding posteriors for $p_{trt}$ and $p_{ctl}$. We impute the participants for whom seroconversion results are pending and combine with the observed data. On the basis of this data we compute the probability of success. If this is greater than the nominated threshold then we claim success and cease further venous sampling. When repeated multiple times on the imputed datasets we obtain a predictive probability of success.

To assess futility, we repeat the equivalent process but impute to the maximum number of seroconversion samples. However, for futility, we compare the proportion of successful trial with a futility threshold, say 5% (see below). If the proportion of successful trials is less than this threshold, we say the trial is futile and cease enrollment.

The final analysis assumes that we have waited until we have all the seroconversion results and then computes the posterior for the difference between the control and treatment arms.

Note - we stop venous sampling at 250 participants.

# Medical attendance modelling
***
Note - we do not start modelling medical attendance until we have 200 enrolled. If we start the time to event analyses from 50 then we are going to get ridiculous results because we will see no events.

The approach is similar to the one adopted for modelling seroconversion. Obviously the modelling assumptions are somewhat different and censoring is also involved.

At each interim we have an increasing number of participants. Each will have been accrued at a certain time and will have an age somewhere between 6 and 12 months at the time of accrual/ranomdisation. Knowing the month of the interim, the accrual time and the age at which they were accrued, we can compute the age at the current interim. If the sum of a participants age and their time to event (see later) is in excess of 36 months (max. follow up time) they are censored with censoring time equal to 36 months. Additionally, if the sum of a participants time to event and the accrual time is in excess of the interim then they are censored. The censoring time is the minimum of the 36 months and the difference between the current interim and the time of accrual.

The time to event model uses a gamma conjugate prior to the exponential likelihood and essentially everything is as per the seroconversion model. We compute the posterior for the parameter of interest (a rate parameter $\gamma$ to the exponential distribution) and generate imputed datasets for the participants that were yet to be observed up to the maximum sample size.

# Decision rules and thresholds
***
The key points are that (1) the trial may be stopped due to futility based on an assessment of either endpoint (2) the trial may be stopped for superiority only on the basis of the clinical endpoint and (3) venous sampling can be stopped based on an assessment of the immunological endpoint.

+ To declare superiority in the immunological endpoint (and cease venous sampling but continue enrolling for the clinical endpoint) we require $\frac{1}{k}\sum_{i=1}^{n_{post}}I(Pr(\delta_{interim} >0)>0.975) > 0.975$ where $n_{post}$ is the number of posterior draws used in imputing the pending observations, $\delta_{interim} = p_{trt} - p_{ctl}$ is the difference between the probability of seroconversion in the treatment and control arms calculated using the observed and imputed seroconversions results to the time of the interim analysis.

+ To declare futility in the immunological endpoint we require $\frac{1}{k}\sum_{i=1}^{n_{post}}I(Pr(\delta_{max n} >0)>0.975) < 0.05$ assessed. In other words, if less than 5% of our simulated datasets result in a successful trial we declare futility and abandon the trial.

+ To declare superiority in the clinical endpoint (and therefore in the trial) we require $Pr(\gamma >0) > 0.975$ where $\gamma = t_{trt} / t_{ctl}$, where $t$ is the median survival time. In other words, if gamma is the ratio in the median survival times then we require that the probability that this difference is in excess of zero be greater than 0.975.

+ To declare futility in the clinical endpoint require $\frac{1}{k}\sum_{i=1}^{n_{post}}I(Pr(\gamma >0)>0.975) < 0.05$ assess at the time when the youngest enrolled child is 36 months (i.e. we include a followup period after the time of maximum participants). In other words, if less than 5% of our simulated datasets result in a successful trial we declare futility.

# Nuance/Limitations
***
The number of individuals is constrained to a maximum of 1000. We assume that funds are available to continue the experiment up to this point regardless of the accrual rate. However, this may not be realistic.

Based on the above rules we can claim superiority in the immunological endpoint, cease venous sampling, but continue enrolling for the clinical endpoint. However, it is possible for the trial to still be inconclusive or futile on the basis of the clinical results.

Delays in information (i.e. in obtaining the blood results) are implemented.

The type i and type ii errors need to be balanced. We might be unwilling to risk incorrectly rejecting the null hypothesis at the 5% significance level. However, decreasing the type i error implicitly increases the type ii error (and therefore reduces power) when the alternative hypothesis is true. If the type i error is really low and the power is not quite where we want it to be then we can trade these two thresholds off against one another to try and improve the overall operating characteristics.

The models are based on conjugate priors -- I tried many other methods, including writing samplers in C++ and approximations. In the actual analysis we will use generalised linear models (logistic regression) and piecewise exponential survival models both estimated with MCMC. These models will likely include additional covariates but the decision process will remain the same. 

See the SAP/Protocol for further details.

-->